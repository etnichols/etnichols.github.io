---
author: Evan Nichols
title: 'Political Computer Science'
date: '2019-1-13'
tags:
  - opinion
draft: true
type: 'post'
---

Republicans are hardware engineers, and Democrats software engineers.

This might be a confusing statement for you. Let's unpack it.

Why are republicans like hardware engineers? Well first, what even is a hardware engineer?

Hardware engineers are people who work on traditionally "low-level" computing systems and components. Here, "low-level" means technology like processors, circuit boards, memory devices, networking systems and routers. These things are not necessarily things you'll interact with too much as a human (unless your internet goes down and you have to restart your router), but they are the things are the building blocks that comprise your phones, computers and other internet-enabled devices. Without the low level hardware behind the scenes, I couldn't be typing this blog post on my computer right now.

...How does those things relate to typically Republican values in any way?

Both hardware engineers and Republicans love efficient, stable systems.

"I just figured out how to cut our " In the world of hardware engineering, efficiency is an absolutely critical design expectation.

"Take this memory-constrained, power-constrained system and make it as efficient as possible and make sure it never crashes."

Hardware engineers strive to maximize the performance of a system using the least amount of chips, connections and components necessary. "Strip it down only the essentials," or, "We need to figure out how to do more with less," might phrases you'd hear a GOP member say during a Congressional budget hearing, or from an embedded systems engineer hardware chip design meeting at Intel. It's an attitude of doing more with less, and it's critical to driving innovation in the tech industry.

Democrats as software engineers. Again, let's first answer the question: what's a software engineer?

Software engineers work on developing applications that run at some "level" on the hardware devices mentioned above... what does "level" mean? Think about the email application running on your phone right now. It allows you to send and recieve email. But how does that actually work? It works via the interaction of a bunch of different "levels" of software running simultaneously. The phone "app" has code developed by a team to make the different screens you can touch and interact with. The app communicates with the phone's firmware (read: low-level software systems that orchestrate allow your phone to connect to interact, capture touch gestures from a user, etc.)

Software engineers also like efficiency. But efficiency is not always the top priority. Software engineers may be more willing to make an application that uses a lot of memory or is incredibly CPU intensive, if it means _being able to solve a critical user problem._ Take Google Chrome for an example: It's a great internet browser that unapologetically eats up a shitload of RAM on your computer while running. "With the right funding and infrastructure, this program could be incredible" might be a phrase you'd hear from a passionate Democratic member at that same Congressional budget hearing, or from a software engineer at a company pitch to a VC firm in Silicon Valley. (Alright, I'm kind of conflating "funding" with processing power here but you get the idea). I think the world of software is first and foremost focused on solving user problems, even if those solutions are sometimes expensive.

Now let's bring them together.

Bad hardware and bad software -- unreliable, things might randomly break, when it does actually work it still sucks

Bad hardware with good software -- unreliable, things might randomly break, when it does actually work its really cool

Good hardware with bad software -- functional, but potentially wasteful and bad UX

Good hardware with good software -- functional, efficient, great user experience

What's the point here?

_We can only make cool things together if hardware and software engineers learn to compromise with each other. Hardware engineers (Republicans) can see the merit in pushing for systems that use more memory or space than they'd prefer, and software engineers (Democrats) must see the merit in critically reviewing a product or service in order to make it as efficient as possible while still solving the user problem._

[1] This is a gross simplification of the idea of software abstraction.
[2] Yet another gross simplification -- this is just one reason why Google Chrome may use more memory than other browsers.
